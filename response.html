<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>API Response - Human readable</title>
  <style>
    body { font-family: Inter, Roboto, -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial; padding: 28px; background:#f7f8fb; color:#111; }
    .card { background: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 6px 18px rgba(20,30,60,0.08); max-width: 900px; margin: 0 auto; }
    h1 { margin: 0 0 8px 0; font-size: 20px; }
    .meta { color:#475569; margin-bottom: 12px; }
    .poem { font-family: Georgia, 'Times New Roman', serif; font-size: 18px; line-height: 1.6; margin: 18px 0; white-space: pre-line; }
    pre.json { background:#0b1220; color:#d6deff; padding:12px; border-radius:6px; overflow:auto; }
    details { margin: 12px 0; }
    .label { font-weight:600; color:#0f172a; }
    .field { margin-bottom:6px; }
    footer { margin-top:18px; color:#64748b; font-size:13px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>API Response (chat.completion)</h1>
    <div class="meta">
      <div class="field"><span class="label">ID:</span> <span id="id"></span></div>
      <div class="field"><span class="label">Model:</span> <span id="model"></span></div>
      <div class="field"><span class="label">Created:</span> <span id="created"></span> <small>(local)</small></div>
    </div>

    <div>
      <div class="label" id="contentLabel">Content</div>
      <div id="content" class="poem"></div>
      <div style="color:#475569; font-size:13px; margin-top:6px;" id="contentMeta"></div>
    </div>

    <!-- Try to synchronously load response_data.js for file:// fallback (if present) -->
    <script>
      try {
        var respScript = document.createElement('script');
        respScript.src = 'response_data.js';
        respScript.defer = false;
        document.head.appendChild(respScript);
      } catch (e) {
        /* ignore */
      }
    </script>

    <details>
      <summary><strong>Model reasoning / internal notes</strong></summary>
      <pre id="reasoning" class="json" style="background:#fff;color:#111;padding:12px;border:1px solid #e6eef8;"></pre>
    </details>

    <div style="margin-top:14px;">
      <div class="label">Full response (pretty JSON)</div>
      <pre id="json" class="json"></pre>
    </div>

    <div style="margin-top:12px; display:flex; gap:12px; align-items:center;">
      <button id="refreshBtn">Refresh now</button>
      <div style="color:#475569; font-size:13px;">Last update: <span id="lastUpdated">never</span></div>
    </div>

    <footer>File generated from runtime `response` captured when running <code>a.py</code>. Use the Refresh button or wait for the automatic poll to update the page.</footer>
  </div>

  <script>
    // Client-side loader: fetch response.json and update the page. Polls every 2 seconds.
    let lastJsonText = null;

    async function loadResponse() {
      // Try to fetch response.json over HTTP
      try {
        const res = await fetch('response.json', {cache: 'no-store'});
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const text = await res.text();
        if (text === lastJsonText) return; // no change
        lastJsonText = text;
        let response;
        try { response = JSON.parse(text); } catch (e) {
          document.getElementById('json').textContent = 'Invalid JSON in response.json:\n' + e + '\n\n' + text;
          return;
        }
        handleResponse(response);
        return;
      } catch (err) {
        // If fetch fails (e.g., opened via file://), try to use window.__RESPONSE from response_data.js
        try {
          if (window.__RESPONSE) {
            const text = JSON.stringify(window.__RESPONSE);
            if (text === lastJsonText) return;
            lastJsonText = text;
            handleResponse(window.__RESPONSE);
            return;
          }
          // attempt to load response_data.js dynamically and then use it
          await new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = 'response_data.js';
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
          });
          if (window.__RESPONSE) {
            const text = JSON.stringify(window.__RESPONSE);
            if (text === lastJsonText) return;
            lastJsonText = text;
            handleResponse(window.__RESPONSE);
            return;
          }
          document.getElementById('json').textContent = 'No response available via fetch or response_data.js.';
          return;
        } catch (e2) {
          document.getElementById('json').textContent = 'Failed to fetch response.json and no local response_data.js available: ' + String(err) + ' / ' + String(e2);
          return;
        }
      }
    }

    // Minimal markdown renderer (safe-ish): supports headings, bold, italics, inline code, code blocks, and lists
    function escapeHtml(str) {
      return str.replace(/[&<>"]+/g, function (s) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]);
      });
    }

    function renderMarkdown(md) {
      if (!md) return '';
      // Normalize line endings
      let text = md.replace(/\r\n?/g, '\n');

      // Escape HTML first
      text = escapeHtml(text);

      // Code blocks ``` ```
      text = text.replace(/```([\s\S]*?)```/g, function(_, code) {
        return '<pre class="json">' + code.replace(/&/g,'&amp;') + '</pre>';
      });

      // Headings
      text = text.replace(/^### (.*$)/gim, '<h3>$1</h3>');
      text = text.replace(/^## (.*$)/gim, '<h2>$1</h2>');
      text = text.replace(/^# (.*$)/gim, '<h1>$1</h1>');

      // Unordered lists
      text = text.replace(/^(?:[-\*] )(.+)$/gim, '<li>$1</li>');
      text = text.replace(/(<li>[\s\S]*?<\/li>)/g, function(m) {
        // group consecutive li into ul
        return '<ul>' + m + '</ul>';
      });

      // Bold **text** and italics *text* or _text_
      text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
      text = text.replace(/_(.*?)_/g, '<em>$1</em>');

      // Inline code `code`
      text = text.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Convert single newlines to <br>
      text = text.replace(/\n/g, '<br>');

      return text;
    }

    function handleResponse(responseTop) {
      // responseTop may be either the old shape or { fetched_at, response }
      let response = responseTop;
      let fetchedAt = null;
      if (responseTop && responseTop.fetched_at && responseTop.response) {
        fetchedAt = responseTop.fetched_at;
        response = responseTop.response;
      }

      document.getElementById('id').textContent = response.id || '';
      document.getElementById('model').textContent = response.model || '';
      document.getElementById('created').textContent = response.created ? new Date(response.created * 1000).toString() : '';

      const choice = response.choices && response.choices[0] ? response.choices[0] : null;
      const message = choice && choice.message ? choice.message : null;
  const content = message && message.content ? message.content : '';
  document.getElementById('content').innerHTML = renderMarkdown(content);

  const reasoning = message && message.reasoning_content ? message.reasoning_content : '';
  document.getElementById('reasoning').innerHTML = renderMarkdown(reasoning);

      if (fetchedAt) {
        try { document.getElementById('lastUpdated').textContent = new Date(fetchedAt * 1000).toLocaleString(); } catch (e) { document.getElementById('lastUpdated').textContent = new Date(fetchedAt).toLocaleString(); }
      }

      document.getElementById('json').textContent = JSON.stringify(response, null, 2);

      const role = message && message.role ? message.role : '';
      const index = choice && typeof choice.index !== 'undefined' ? choice.index : '';
      document.getElementById('contentMeta').textContent = (role ? ('Role: ' + role) : '') + (index !== '' ? (' â€” choice ' + index) : '');
    }

    // Poll every 2 seconds and update timestamp only when JSON changes
    const pollInterval = 2000;
    async function pollLoop() {
      const before = lastJsonText;
      await loadResponse();
      if (lastJsonText !== before) {
        document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
      }
    }

    // Start the polling loop
    pollLoop();
    setInterval(pollLoop, pollInterval);

    // Manual refresh
    document.getElementById('refreshBtn').addEventListener('click', () => {
      lastJsonText = null; // force update
      pollLoop();
    });
  </script>
</body>
</html>
